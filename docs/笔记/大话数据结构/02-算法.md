# 算法

## 算法的定义

算法是解决特定问题的求解步骤的描述，在计算机中是指令的有限序列，并且每个指令可以有一个或多个操作。

## 算法的特性

算法具有输入、输出、有穷性、确定性和可行性

### 输入输出

算法具有零个或者多个的输入，至少一个或多个的输出

### 有穷性

算法在执行有限的步骤后，程序会自动结束而不是死循环，且每个步骤的执行时间都在可接受范围内

### 确定性

每个步骤的执行结果具有确定的含义，不具有二义性

### 可行性

每个步骤都是可行的，执行有限次数后完成

## 算法设计要求

### 正确性

指算法至少需要输入、输出和加工处理无歧义性，能正确反映问题的需求，能够得到问题的正确答案

### ⭐ 可读性

算法要便于阅读、理解和交流

### 健壮性

当输入不合法时，能够做出相关的处理，而不是抛出异常或者产生莫名其妙的结构

### ⭐ 时间效率高和存储量低

算法应该尽量满足时间效率高和存储量低的需求

## 算法效率的度量方法

### 事后统计方法

:::tip
通过设计好的测试程序和数据，利用计算机的计时器对不同算法编制的程序运行时间进行比较，从而确定算法效率的高低
:::

该方法具有以下缺陷

1. 需要花费大量时间编写测试程序，如果编译出来程序本身很烂，那么就是浪费时间
2. 程序运行环境不同
3. 测试数据设计困难

### 事前分析估算方法

在计算机编译前，依据统计方法对算法进行估算。

从 1 加到 100，第一种算法

```javascript
let sum = 0;
const n = 100;
let i = 1;
for (; i <= n; i++) {
  sum += i; // 执行 n 次
}
console.log(sum);
```

第二种算法

```javascript
const n = 100;
const sum = ((1 + n) * n) / 2; // 执行了 1 次
console.log(sum);
```

第三种是第一种的延伸

```javascript
let x = 0;
let sum = 0;
const n = 100;
for (let i = 1; i <= n; i++) {
  for (let j = 1; j <= n; j++) {
    x++;
    sum += x; // 执行 n * n 次
  }
}
console.log(sum);
console.log(x);
```

三种例子花费的时间函数如下

- 第一种 f(n) = n
- 第二种 f(n) = 1
- 第三种 f(n) = n^2

:::tip
在分析一个算法的运行时间时，重要的是把基本的操作数量和输入规模关联起来，即基本操作的数量必须表示成输入规模的函数。
:::

> 不计那些循环引用的递增和循环终止条件、变量声明、打印结果等操作。

## 函数的渐近增长

可先通过例子观察

| 次数     | 算法 A(2n + 3) | 算法 A'(2n) | 算法 B(3n+1) | 算法 B'(3n) |
| -------- | -------------- | ----------- | ------------ | ----------- |
| n = 1    | 5              | 2           | 4            | 3           |
| n = 2    | 7              | 4           | 7            | 6           |
| n = 3    | 9              | 6           | 10           | 9           |
| n = 10   | 23             | 20          | 31           | 30          |
| n = 100  | 203            | 200         | 301          | 300         |
| n = 1000 | 2003           | 2000        | 3001         | 3000        |

可以看出 n > 2 后，算法 B 的增长快于算法 A

> 给定两个函数 f(n) 和 g(n)，如果存在一个整数 N，使得对于所有 n > N，f(n) 总是比 g(n) 大，那么可以说明 f(n) 的渐近增长快于 g(n)

:::tip
判断一个算法的效率时，函数中的常数和其他次要项常常可以忽略，而更应该关注主项（最高阶项）的阶数
:::

:::warning
某个算法，随着 n 的增大，它会越来越优于另一算法，或者越来越差于另一算法。

这其实就是事前预估方法的理论依据，通过**算法时间复杂度**来预估**算法时间效率**
:::

## 算法时间复杂度

:::tip
时间复杂度记作 T(n) = O(f(n))。表示随问题规模 n 的增大，算法执行时间的增长率和 f(n) 的增长率相同，称作算法的渐近时间复杂度，简称为时间复杂度。其中 f(n) 是问题规模 n 的某个函数。
:::

:::warning
《大话数据结构》一书中，将

$$
O(1)称为常数阶，O(n) 称为线性阶，O(n^2) 称为平方阶。
$$

以上都是非官方的称呼
:::

使用 O() 这种记法被称为 **大 O 阶**

### 推导大 O 阶方法

1. 用常数 1 取代运行时间中的所有加法常数
2. 在修改后的运行次数函数中，只保留最高阶项
3. 如果最高阶项存在且其系数不是 1，则去除与这个项相乘的系数。得到的结果就是大 O 阶

### 常数阶

```javascript
const n = 100; // 执行一次
const sum = ((1 + n) * n) / 2; // 执行一次
console.log(sum); // 执行一次
```

时间运行函数 f(n) = 3，根据大 O 阶推导方法中，用 1 取代常数，得到的时间复杂度为 O(1)

### 线性阶

要确定某个算法的阶次，常常需要确定某个循环语句或某个语句集运行的次数。

:::tip
分析算法的复杂度，关键就是分析循环结构的运行情况
:::

以下代码的时间复杂度为 O(n)，因为在循环体中运行了 n 次

```javascript
for (let i = 0; i < n; i++) {
  // 时间复杂度为 O(1) 的程序步骤序列
}
```

### 对数阶

```javascript
let count = 1;
while (count < n) {
  count = count * 2;
  // 时间复杂度为 O(1) 的程序步骤序列
}
```

以上程序表示 count 每次和 2 相乘，就会距离 n 更近一些。也就是说，多少个 2 相乘后大于 n

$$
由 2^x = n 得x=\log_2n
$$

所以时间复杂度为 O(logn)

### 平方阶

$$
下面的例子时间复杂度为 O(n^2)
$$

```javascript
for (let i = 0; i < n; i++) {
  for (let j = 0; j < n; j++) {
    // 时间复杂度为 O(1) 的程序步骤序列
  }
}
```

$$
以下例子时间复杂度为 O(nm)
$$

```javascript
for (let i = 0; i < m; i++) {
  for (let j = 0; j < n; j++) {
    // 时间复杂度为 O(1) 的程序步骤序列
  }
}
```

:::tip
循环的时间复杂度等于循环体的复杂度乘以该循环运行的次数
:::

## 常见的时间复杂度

| 执行次数函数       | 阶       | 非正式术语 |
| ------------------ | -------- | ---------- |
| 12                 | O(1)     | 常数阶     |
| 2n + 3             | O(n)     | 线性阶     |
| 3n² + 2n + 1       | O(n²)    | 平方阶     |
| 5logn + 20         | O(logn)  | 对数阶     |
| 2n + 3nlogn + 19   | O(nlogn) | nlogn 阶   |
| 3n³ + 2n² + 3n + 4 | O(n³)    | 立方阶     |
| 2^n                | O(2^n)   | 指数阶     |

:::danger
常用的时间复杂度消耗时间从小到大依次是

O(1) < O(logn) < O(n) < O(nlogn) < O(n²) < O(n³) < O(2^n) < O(n!) < O(n^n)
:::

:::tip
一般情况下，提到的运行时间都是指最坏的时间复杂度
:::

## 算法空间复杂度

:::tip
算法的空间复杂度通过计算算法所需的存储空间实现，算法空间复杂度的计算公式记作：S(n) = O(f(n))。其中，n 为问题的规模，f(n) 为语句关于 n 所占存储空间的函数
:::
